<p>
  This section describes the consensus network connectors
  supported by Reach version ${VERSION}.
</p>
<h2 id="algorand">Algorand</h2>
<p>
  The <a href="https://www.algorand.com/">Algorand</a> Reach connector generates a set of
  contracts that manage one instance of the DApp's
  execution.
</p>
<p>
  It uses finite on-chain state.
  The DApp consists of one application and one contract-controlled escrow account.
</p>
<p>
  It relies on versions of <code>algod</code> that support TEAL version 4, such as Algorand 2.7.1 from July 2021.
  It uses the Algorand <code>indexer</code> version 2 to lookup and monitor publications; in other words, it does <em>not</em> rely on any communication network other than Algorand itself.
</p>
<p>
  Algorand uses the SHA256 algorithm to perform digests.
  Its bit width is 64-bits.
</p>
<p>
  Non-network tokens are compiled to <a href="https://developer.algorand.org/docs/features/asa/">Algorand Standard Assets</a> (ASAs).
  Specifically, the <code>Token</code> type refers to the id of the ASA.
</p>
<p>
  Token minting creates an ASA owned and managed by the contract account.
  Freezing, clawback, reserves, and separate managers are not supported.
</p>
<p>
  Algorand's ASAs are extremely powerful and Reach's static reasoning about them makes some unsound assumptions about how they will behave in practice.
  First, it is possible to "freeze" an asset, which disables the ability of contracts (and users) from transfering their assets, without prior notification that the asset is frozen (i.e., in one moment, a contract may transfer an asset, but then in the next moment, without any change to the contract state, it ceases to be able to transfer it, because elsewhere in the network, an asset was frozen.)
  Second, the assets support "clawback", which extracts assets from an account without approval by or notification of the account holder.
  Third, the assets require that receivers "opt-in" (or give prior approval) before an account can transfer assets to them.
  Fourth, this prior approval may be removed, or rather accounts can "opt-out" and take-back the permission to transfer assets to them after having previously given it.
  Each of these issues mean that rely-guarantee reasoning is not appropriate for analyzing consensus steps on Algorand: in other words, it is not possible to guarantee from the structure of a program that consensus steps which are dominated by honest interactions will succeed, because external agents can arbitrarily influence the outcomes of consensus operations, without informing the contract.
  This essentially amounts to all Algorand DApps that use non-network tokens being inherently vulnerable to denial-of-service attacks when assets use these features.
</p>
<p>
  For example, if a DApp has a consensus step where Alice will receive 1 gil and Bob will receive 2 zorkmids, either Alice or Bob can prevent this step from executing by opting out of (respectively) gil or zorkmids.
  (An "opt-out" is performed by sending an <a href="https://developer.algorand.org/docs/reference/transactions/#asset-transfer-transaction">Asset Transfer Transaction</a> (<code>axfer</code>) with a non-zero <code>AssetCloseTo</code> field.)
  You can alleviate this problem by ensuring that any non-network token transfers occur as the last consensus steps of the program and may be executed in any order by the recipient of the funds.
  Similarly, if a DApp accepts a non-network token that has enabled clawback, then it can be prevented from progressing if the manager takes the contract's tokens behind its back.
</p>
<p>
  There are three options for dealing with these issues.
  First, refuse to accept assets that have the possibility of clawback or freezing; but this is not practical, because tokens default to allowing these features and many of the popular assets use them as well.
  Second, incorporate the possibility that all non-network token functions might fail into the verification engine; but this is not practical, because there is no way to dynamically check if the operation will succeed and it is not feasible to have an alternative path if it won't.
  Third, pretend that assets don't actually support these features and warn developers about the risks.
  Reach goes with the third option.
  We hope that future versions of Algorand will provide a facility making other options practical.
</p>
<p>
  Views are compiled to client-side functions that can interpret the global and local state of the Algorand Application associated with the DApp.
  This means they are sensitive to the particular compilation details of the particular Reach program.
  We hope to work with the Algorand community to define a standard for views.
  Views expand the on-chain state to include the free variables of all values bound to a view.
</p>
<p>
  Linear state is compiled into Application Local State.
  This means that participants must explicitly "opt-in" to storing this state on their account (which increases their minimum balance).
  The Reach standard library will do this automatically when connecting to Reach generated contracts, but other users must be specifically programmed to do this.
  This "opt-in" requirement means that DApps with linear state deployed on Algorand can deadlock and be held hostage:
  Suppose that Alice transfers 10 ALGO to a contract in step one, then in step two, the consensus must store a value associated with Bob, and then she can receive her 10 ALGO back, then the program terminates.
  On some networks, Alice can perform these two steps completely on her own and she is in complete control of her funds.
  However, on Algorand, running this program requires that Bob "opt-in" to storing values for the application.
  We hope that future versions of Algorand will allow other parties to pay the fees to "opt-in" to applications to prevent these kinds of deadlock attacks.
</p>
<p>
  In Algorand, network time corresponds to round numbers and network seconds correspond to the Unix timestamp of the previous round.
  (This is because the current round's timestamp is not determined until after it is finalized.
  This means that a network second-based deadline could be exceeded by the round time of the network, which is typically five seconds.)
</p>
<p>
  The connector provides a binding named <code>ALGO</code> to
  backends.
</p>
<p>Backends must respect the following environment variables:</p>
<ul>
  <li><code>ALGO_TOKEN</code> is used as the API token for your <code>algod</code>.</li>
  <li><code>ALGO_SERVER</code> is used as the address of your <code>algod</code>.</li>
  <li><code>ALGO_PORT</code> is used as the port of your <code>algod</code>.</li>
  <li><code>ALGO_INDEXER_TOKEN</code> is used as the API token for your <code>indexer</code>.</li>
  <li><code>ALGO_INDEXER_SERVER</code> is used as the address of your <code>indexer</code>.</li>
  <li><code>ALGO_INDEXER_PORT</code> is used as the port of your <code>indexer</code>.</li>
  <li>
    <code>ALGO_FAUCET_PASSPHRASE</code> is used as the mnemonic for the faucet of your network.
    This is useful if you are running your own testing network.
  </li>
</ul>
<h2 id="conflux">Conflux</h2>
<p>The <a href="https://confluxnetwork.org/">Conflux</a> Reach connector works almost identically to the <a href="##ref-network-eth">Ethereum connector</a>, except that it behaves differently at runtime: using, for example, <a href="https://portal.confluxnetwork.org/">Conflux Portal</a> rather than <a href="https://metamask.io/">MetaMask</a>, and connecting to Conflux nodes.</p>
<p>Backends must respect the following environment variables:</p>
<ul>
  <li>
    <code>CFX_NODE_URI</code> is used to contact the Conflux node.
    It defaults to <code>http://localhost:12537</code>.
  </li>
  <li>
    <code>CFX_NETWORK_ID</code> is used to determine the Conflux network id.
    It defaults to <code>999</code>.
  </li>
</ul>
<h3 id="faq">FAQ</h3>
<h4 id="how-do-i-run-my-reach-dapp-on-cfx-testnet-or-mainnet">How do I run my Reach DApp on CFX TestNet or MainNet?</h4>
<p>
  You can add the following JavaScript near the beginning of your index.js or index.mjs file
  in order to run on Conflux TestNet:
</p>
<pre class="snippet numbered"><ol class="snippet"><li value="1"><span style="color: #24292E">reach.</span><span style="color: #6F42C1">setProviderByName</span><span style="color: #24292E">(</span><span style="color: #032F62">'TestNet'</span><span style="color: #24292E">);</span></li></ol></pre>
<p>Or this to run on Conflux MainNet:</p>
<pre class="snippet numbered"><ol class="snippet"><li value="1"><span style="color: #24292E">reach.</span><span style="color: #6F42C1">setProviderByName</span><span style="color: #24292E">(</span><span style="color: #032F62">'MainNet'</span><span style="color: #24292E">);</span></li></ol></pre>
<p>
  It is strongly recommended that you also use <code>setQueryLowerBound</code>
  to avoid waiting for unnecessary queries.
  For example, this code snippet sets the lower bound at 2000 blocks ago:
</p>
<pre class="snippet numbered"><ol class="snippet"><li value="1"><span style="color: #D73A49">const</span><span style="color: #24292E"> </span><span style="color: #005CC5">now</span><span style="color: #24292E"> </span><span style="color: #D73A49">=</span><span style="color: #24292E"> </span><span style="color: #D73A49">await</span><span style="color: #24292E"> reach.</span><span style="color: #6F42C1">getNetworkTime</span><span style="color: #24292E">();</span></li><li value="2"><span style="color: #24292E">reach.</span><span style="color: #6F42C1">setQueryLowerBound</span><span style="color: #24292E">(reach.</span><span style="color: #6F42C1">sub</span><span style="color: #24292E">(now, </span><span style="color: #005CC5">2000</span><span style="color: #24292E">));</span></li></ol></pre>
<h4 id="why-is-dapp-startup-very-slow-why-do-i-need-to-use-setquerylowerbound">Why is DApp startup very slow? Why do I need to use <code>setQueryLowerBound</code>?</h4>
<p>
  DApp startup doesn't have to be slow.
  Reach relies on querying Conflux event logs in order to run the DApp.
  The Conflux network does not yet provide fast APIs for querying event logs for a given contract across all time,
  so instead, Reach incrementally queries across chunks of 1000 blocks at a time.
  You can use <code>setQueryLowerBound</code> to help Reach know at what block number to start querying,
  so that it does not have to start querying at the beginning of time, which can take quite a while.
</p>
<h4 id="how-can-i-use-confluxportal-with-the-reach-devnet">How can I use ConfluxPortal with the Reach devnet?</h4>
<p>
  If you find that ConfluxPortal's Localhost 12537 default configuration does not work correctly with Reach apps,
  you can try configuring ConfluxPortal to use a custom RPC endpoint:
</p>
<ul>
  <li>Click the network dropdown in Conflux Portal</li>
  <li>Select: Custom RPC</li>
  <li>Use RPC url: <a href="http://127.0.0.1:12537">http://127.0.0.1:12537</a></li>
</ul>
<p>
  If your locally-running Conflux devnet restarts,
  you may find that you need to reset ConfluxPortal's account history,
  which you can do like so:
</p>
<ul>
  <li>Select the desired account</li>
  <li>Click the profile image of the account (top-right)</li>
  <li>Click Settings &gt; Advanced &gt; Reset Account &gt; (confirm) Reset</li>
  <li>Switch to a different network and back</li>
  <li>CTRL+SHIFT+R to hard-reset the webpage.</li>
</ul>
<h2 id="ethereum">Ethereum</h2>
<p>
  The <a href="https://ethereum.org/">Ethereum</a> Reach connector generates a contract that
  manages one instance of the DApp's execution.
  It is guaranteed to
  use exactly one word of on-chain state, while each piece of consensus state appears as a transaction argument.
</p>
<p>
  Ethereum uses the Keccak256 algorithm to perform digests.
  Its bit width is 256-bits.
</p>
<p>
  Non-network tokens are compiled to <a href="https://ethereum.org/en/developers/docs/standards/tokens/erc-20/">ERC-20</a> fungible tokens.
  Specifically, the <code>Token</code> type refers to the address of the ERC-20 contract.
  Token minting launches a fresh ERC-20 contract based on the OpenZeppelin ERC-20 implementation, which stores additional metadata and allows the creator to burn tokens and destroy the token if there is no supply (i.e. it has all been burned).
</p>
<p>
  Views are compiled to <code>view</code> functions.
  A view named <code>X.Y</code> will be named <code>X_Y</code>.
  Views expand the on-chain state to include the free variables of all values bound to a view.
</p>
<p>In Ethereum, network time corresponds to block numbers and network seconds correspond to the Unix timestamp of the block.</p>
<p>
  The connector provides a binding named <code>ETH</code> to
  backends.
</p>
<p>
  During compilation, the connector produces one intermediate output: <code>input.export.sol</code>, containing
  the Solidity code implementing the contract.
</p>
<p>
  A few details of Ethereum leak through to Reach.
  The node that a given participant is connected to does not instantly know that its blocks are correct and may revert past transactions after it reaches consensus with the rest of the network.
  This means that Reach applications must not make externally observable effects until after such consensus is reached.
</p>
<p>Backends must respect the following environment variables:</p>
<ul>
  <li>
    <code>ETH_NODE_URI</code> is used to contact the Ethereum node.
    It defaults to <code>http://localhost:8545</code>.
  </li>
  <li>
    <code>ETH_NODE_NETWORK</code> is used to name the Ethereum network.
    It defaults to <code>unspecified</code>.
  </li>
</ul>