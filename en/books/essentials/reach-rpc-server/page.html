<p>The Reach RPC Server provides access to compiled JavaScript backends via an HTTPS-accessible JSON-based RPC protocol. The server allows frontends to be written in any programming language. Reach provides client libraries for JavaScript, Python, and Go. It is easy to implement a client library yourself. An example frontend written using the Reach RPC Server is shown in the tutorial section on RPC-based frontends.</p>
<p>The command <code>reach rpc-server</code> starts an instance of the Reach RPC Server.</p>
<h1 id="rpc-methods">RPC Methods</h1>
<p>The Reach RPC Server supports the following RPC methods:</p>
<ul>
  <li>
    <p><code>/health</code> returns true to indicate the server is running properly.</p>
  </li>
  <li>
    <p><code>/stdlib/$METHOD</code> where <code>$METHOD</code> is a function of the JavaScript standard library.</p>
    <p>All <code>/stdlib</code> methods are synchronous value RPC methods that accept and produce the same arguments and return values as the corresponding function, encoded as JSON objects, except those that produce or consume account representations.</p>
    <p>Those methods instead accept and produce account RPC handles, which are random strings that represent the corresponding account representations. For example, <code>/stdlib/newTestAccount</code> does not return an account like <code>newTestAccount</code>, but instead returns an account RPC handle.</p>
  </li>
  <li>
    <p><code>/forget/acc</code> accepts an account RPC handle and deletes it from the Reach RPC Server’s memory.</p>
  </li>
  <li>
    <p><code>/acc/$METHOD</code> where <code>$METHOD</code> is a method of an account representation of the JavaScript standard library.</p>
    <p>All <code>/acc</code> methods are synchronous value RPC methods that accept and produce the same arguments and return values as the corresponding function, encoded as JSON objects, except they accept an additional first argument, which is the account RPC handle returned by a prior RPC method invocation; and, a method that accepts a backend (like /acc/attach (i.e. acc.attach) or /acc/deploy (i.e. acc.deploy) does not accept a backend argument, but has it implicitly provided by the Reach RPC Server.</p>
    <p>Furthermore, those that produce contract representations, instead produce contract RPC handles. For example, /acc/deploy does not return a contract representation like acc.deploy, but instead returns a contract RPC handle.</p>
  </li>
  <li>
    <p><code>/forget/ctc</code> accepts a contract RPC handle and deletes it from the Reach RPC Server’s memory.</p>
  </li>
  <li>
    <p><code>/ctc/$METHOD</code> where <code>$METHOD</code> is a method of a contract representation of the JavaScript standard library.</p>
    <p>All <code>/ctc</code> methods are synchronous value RPC methods that accept and produce the same arguments and return values as the corresponding function, encoded as JSON objects, except they accept an additional first argument, which is the contract RPC handle returned by a prior RPC method invocation.</p>
  </li>
  <li>
    <p><code>/backend/$PARTICIPANT</code> where <code>$PARTICIPANT</code> is a participant of the backend compiled by the JavaScript backend.</p>
    <p>All <code>/backend</code> methods are interactive RPC methods that accept three arguments:</p>
    <p><code>ctcId</code> — A contract RPC handle to provide as the contract to the backend</p>
    <p><code>values</code> — An object containing the non-function components of the participant interact interface of the backend.</p>
    <p><code>methods</code> — An object whose keys correspond to the function components of the participant interact interface of the backend, but whose values are true.</p>
    <p>As a special case, if values contains stdlib.hasRandom bound to true, then the JavaScript standard library’s implementation of hasRandom is provided to the backend.</p>
    <p>As the backend executes, any of the components of methods invoked will be executed as interactive RPC callbacks as described by the Reach RPC Protocol Specification. Reach RPC Client libraries should expose a function that hides the details of the construction of the values and methods objects and implements interactive RPC callback handlers automatically.</p>
  </li>
  <li>
    <p><code>/kont</code> handles interactive RPC continuation completion during an interactive RPC method. It should not be invoked directly by frontends.</p>
  </li>
  <li>
    <p><code>/stop</code> quits the server.</p>
  </li>
</ul>
<h1 id="client-options">Client Options</h1>
<p>Reach RPC client libraries must accept a dictionary data structure with the following keys for customizing their behavior:</p>
<ul>
  <li>
    <p>host — This value sets the hostname to contact for the Reach RPC Server instance. If it is not present, the client library must default to the value of the environment variable REACH_RPC_SERVER.</p>
  </li>
  <li>
    <p>port — This value sets the TCP port to contact for the Reach RPC Server instance. If it is not present, the client library must default to the value of the environment variable REACH_RPC_PORT.</p>
  </li>
  <li>
    <p>verify — This value determines whether to verify the TLS certificate of the Reach RPC Server instance. If it is not present, the client library must default to the value of the environment variable REACH_RPC_TLS_REJECT_UNVERIFIED. If that is not present, it must default to true.</p>
    <p>To disable verification, set this value to the string: "0"; any other value will be considered to mean "enable".</p>
  </li>
  <li>
    <p>timeout — This value sets the number of seconds to wait for the Reach RPC Server instance to respond to its first request. If it is not present, the client library must default to the value of the environment variable REACH_RPC_TIMEOUT. If that is not present, it must default to 5 seconds.</p>
  </li>
  <li>
    <p>key — This value sets the API key for the Reach RPC Server instance. If it is not present, the client library must default to the value of the environment variable REACH_RPC_KEY.</p>
  </li>
</ul>
<h1 id="protocol-specification">Protocol Specification</h1>
<p>The Reach RPC Protocol (hereafter, "the protocol" or "it") is an instance of JSON-based RPC protocol.</p>
<p>It should be transported over HTTPS (i.e. HTTP over TLS).</p>
<p>Requests must include an X-API-Key header whose value is a shared secret between a server instance and an RPC client, referred to as the API key. Typically this value comes from the environment variable REACH_RPC_KEY and is the Base64 encoding of 24 random bytes.</p>
<p>Requests must use the POST HTTP method.</p>
<p>Requests specify the RPC method to be invoked via the HTTP request target.</p>
<p>Requests must include a JSON-encoded array in their body. Requests should indicate this by setting the Content-Type header to application/json; charset=utf-8. This array is interpreted as the arguments to the RPC method.</p>
<p>Responses must include a JSON-encoded value in their body. Responses should indicate this by setting the Content-Type header to application/json; charset=utf-8.</p>
<p>Responses may include RPC handles, which are strings that represent intermediate resources held on the RPC server that cannot be serialized to JSON.</p>
<p>RPC methods are either synchronous value RPC methods or interactive RPC methods.</p>
<h2 id="synchronous-value-rpc-methods">Synchronous Value RPC Methods</h2>
<p>Synchronous value RPC methods consume arguments and produce a single result without further interaction with the client. The result is the body of the response.</p>
<p>For example, formatCurrency is a synchronous value RPC method. A call to formatCurrency("19283.1035819471", 4) would be represented by the following HTTP session, with request lines indicated by + and response lines indicated by -:</p>
<pre class="snippet numbered"><ol class="snippet"><li value="1">+ POST /stdlib/formatCurrency HTTP/1.1</li><li value="2">+ X-API-Key: OpenSesame</li><li value="3">+ Content-Type: application/json; charset=utf-8</li><li value="4">+</li><li value="5">+ [ "19283.1035819471", 4 ]</li><li value="6">- HTTP/1.1 200 OK</li><li value="7">- Content-Type: application/json; charset=utf-8</li><li value="8">-</li><li value="9">- "19283.1035"</li></ol></pre>
<h2 id="interactive-rpc-methods">Interactive RPC Methods</h2>
<p>Interactive RPC methods consume arguments, including a specification of interactive RPC callbacks, and produce an interactive RPC continuation.</p>
<p>An interactive RPC callback is a key of a JSON object, bound to true, that indicates that the initiator of an interactive RPC method responds to requests for further data during the execution of this call.</p>
<p>An interactive RPC continuation is a JSON object that matches either:</p>
<ul>
  <li>
    <p><code>{t: "Done", ans}</code>, where ans is the final result of the original interactive RPC method.</p>
  </li>
  <li>
    <p><code>{t: "Kont", kid, m, args}</code>, where kid is an RPC handle, m is a string naming one of the interactive RPC callback methods, and args is an array of the arguments to that method.</p>
  </li>
</ul>
<p>When a <code>Kont</code> value is produced, then the interactive RPC method is suspended until the /kont RPC method is invoked with the continuation RPC handle and the return value of the interactive RPC callback. The result of the /kont RPC method is another interactive RPC continuation.</p>
<p>Clients may perform any RPC methods while an interactive RPC method is suspended.</p>
<p>The server may re-use the same interactive RPC continuation handle many times.</p>
<p>For example, the execution of a backend is an interactive RPC method. An example interaction might be represented by the following HTTP session, with request lines indicated by + and response lines indicated by -:</p>
<pre class="snippet numbered"><ol class="snippet"><li value="1">+ POST /backend/Alice HTTP/1.1</li><li value="2">+ X-API-Key: OpenSesame</li><li value="3">+ Content-Type: application/json; charset=utf-8</li><li value="4">+</li><li value="5">+ [ "Contract-42", { "price": 10 }, { "showX": true } ]</li><li value="6">- HTTP/1.1 200 OK</li><li value="7">- Content-Type: application/json; charset=utf-8</li><li value="8">-</li><li value="9">- { t: "Kont", kid: "Kont-A", m: "showX", args: [ "19283.1035819471" ] }</li><li value="10">+ POST /stdlib/formatCurrency HTTP/1.1</li><li value="11">+ X-API-Key: OpenSesame</li><li value="12">+ Content-Type: application/json; charset=utf-8</li><li value="13">+</li><li value="14">+ [ "19283.1035819471", 4 ]</li><li value="15">- HTTP/1.1 200 OK</li><li value="16">- Content-Type: application/json; charset=utf-8</li><li value="17">-</li><li value="18">- "19283.1035"</li></ol></pre>
<pre class="snippet numbered"><ol class="snippet"><li value="1">+ POST /kont HTTP/1.1</li><li value="2">+ X-API-Key: OpenSesame</li><li value="3">+ Content-Type: application/json; charset=utf-8</li><li value="4">+</li><li value="5">+ [ "Kont-A", null ]</li><li value="6">- HTTP/1.1 200 OK</li><li value="7">- Content-Type: application/json; charset=utf-8</li><li value="8">-</li><li value="9">- { t: "Done", ans: null }</li></ol></pre>
<h1 id="implementation-walkthrough">Implementation Walkthrough</h1>
<p>The Reach RPC Protocol is designed to be simple to implement in languages that support HTTP and JSON interaction. This document walks through the implementation of an <a href="https://github.com/reach-sh/reach-lang/blob/master/rpc-client/py/src/reach_rpc/__init__.py">RPC client in Python</a>. An example use of this library is shown in the tutorial section on RPC-based frontends. The entire library is 80 lines of code.</p>
<h2 id="standard-libraries">Standard Libraries</h2>
<p>The library uses a few standard Python libraries for interacting with JSON, HTTP servers, and networking:</p>
<pre class="snippet numbered"><ol class="snippet"><li value="1"><span style="color: #6A737D"># flake8: noqa</span></li><li value="2"></li><li value="3"><span style="color: #D73A49">import</span><span style="color: #24292E"> json</span></li><li value="4"><span style="color: #D73A49">import</span><span style="color: #24292E"> os</span></li><li value="5"><span style="color: #D73A49">import</span><span style="color: #24292E"> requests</span></li><li value="6"><span style="color: #D73A49">import</span><span style="color: #24292E"> socket</span></li><li value="7"><span style="color: #D73A49">import</span><span style="color: #24292E"> time</span></li><li value="8"><span style="color: #D73A49">import</span><span style="color: #24292E"> urllib3</span></li></ol></pre>
<h2 id="define-mk_rpc">Define mk_rpc</h2>
<p>The library provides a single function, <code>mk_rpc</code>, that accepts the Reach RPC Client Standard Options:</p>
<pre class="snippet numbered"><ol class="snippet"><li value="11"><span style="color: #D73A49">def</span><span style="color: #24292E"> </span><span style="color: #6F42C1">mk_rpc</span><span style="color: #24292E">(opts</span><span style="color: #D73A49">=</span><span style="color: #24292E">{}):</span></li><li value="12"><span style="color: #24292E">    </span><span style="color: #D73A49">def</span><span style="color: #24292E"> </span><span style="color: #6F42C1">opt_of</span><span style="color: #24292E">(field, envvar, default</span><span style="color: #D73A49">=</span><span style="color: #005CC5">None</span><span style="color: #24292E">, f</span><span style="color: #D73A49">=lambda</span><span style="color: #24292E"> x: x):</span></li><li value="13"><span style="color: #24292E">        opt </span><span style="color: #D73A49">=</span><span style="color: #24292E">  f(opts.get(field))        </span><span style="color: #D73A49">if</span><span style="color: #24292E"> opts.get(field)        </span><span style="color: #D73A49">is</span><span style="color: #24292E"> </span><span style="color: #D73A49">not</span><span style="color: #24292E"> </span><span style="color: #005CC5">None</span><span style="color: #24292E"> \</span></li><li value="14"><span style="color: #24292E">          </span><span style="color: #D73A49">else</span><span style="color: #24292E"> f(os.environ.get(envvar)) </span><span style="color: #D73A49">if</span><span style="color: #24292E"> os.environ.get(envvar) </span><span style="color: #D73A49">is</span><span style="color: #24292E"> </span><span style="color: #D73A49">not</span><span style="color: #24292E"> </span><span style="color: #005CC5">None</span><span style="color: #24292E"> \</span></li><li value="15"><span style="color: #24292E">          </span><span style="color: #D73A49">else</span><span style="color: #24292E"> default</span></li><li value="16"></li><li value="17"><span style="color: #24292E">        </span><span style="color: #D73A49">if</span><span style="color: #24292E"> opt </span><span style="color: #D73A49">is</span><span style="color: #24292E"> </span><span style="color: #005CC5">None</span><span style="color: #24292E">:</span></li><li value="18"><span style="color: #24292E">            </span><span style="color: #D73A49">raise</span><span style="color: #24292E"> </span><span style="color: #005CC5">RuntimeError</span><span style="color: #24292E">(</span><span style="color: #032F62">'Mandatory configuration unset for: </span><span style="color: #005CC5">%s</span><span style="color: #032F62">'</span><span style="color: #24292E"> </span><span style="color: #D73A49">%</span><span style="color: #24292E"> field)</span></li><li value="19"></li><li value="20"><span style="color: #24292E">        </span><span style="color: #D73A49">return</span><span style="color: #24292E"> opt</span></li><li value="21"></li><li value="22"><span style="color: #24292E">    host    </span><span style="color: #D73A49">=</span><span style="color: #24292E"> opt_of(</span><span style="color: #032F62">'host'</span><span style="color: #24292E">,    </span><span style="color: #032F62">'REACH_RPC_SERVER'</span><span style="color: #24292E">)</span></li><li value="23"><span style="color: #24292E">    port    </span><span style="color: #D73A49">=</span><span style="color: #24292E"> opt_of(</span><span style="color: #032F62">'port'</span><span style="color: #24292E">,    </span><span style="color: #032F62">'REACH_RPC_PORT'</span><span style="color: #24292E">)</span></li><li value="24"><span style="color: #24292E">    key     </span><span style="color: #D73A49">=</span><span style="color: #24292E"> opt_of(</span><span style="color: #032F62">'key'</span><span style="color: #24292E">,     </span><span style="color: #032F62">'REACH_RPC_KEY'</span><span style="color: #24292E">)</span></li><li value="25"><span style="color: #24292E">    timeout </span><span style="color: #D73A49">=</span><span style="color: #24292E"> opt_of(</span><span style="color: #032F62">'timeout'</span><span style="color: #24292E">, </span><span style="color: #032F62">'REACH_RPC_TIMEOUT'</span><span style="color: #24292E">,               </span><span style="color: #E36209">f</span><span style="color: #D73A49">=</span><span style="color: #005CC5">int</span><span style="color: #24292E">, </span><span style="color: #E36209">default</span><span style="color: #D73A49">=</span><span style="color: #005CC5">5</span><span style="color: #24292E">)</span></li><li value="26"><span style="color: #24292E">    verify  </span><span style="color: #D73A49">=</span><span style="color: #24292E"> opt_of(</span><span style="color: #032F62">'verify'</span><span style="color: #24292E">,  </span><span style="color: #032F62">'REACH_RPC_TLS_REJECT_UNVERIFIED'</span><span style="color: #24292E">, </span><span style="color: #E36209">f</span><span style="color: #D73A49">=lambda</span><span style="color: #24292E"> x: x </span><span style="color: #D73A49">!=</span><span style="color: #24292E"> </span><span style="color: #032F62">'0'</span><span style="color: #24292E">)</span></li></ol></pre>
<h2 id="turn-off-warnings">Turn off warnings</h2>
<p>It starts by observing the verify option and informing the Python library it uses for HTTPS interaction to turn off warnings. It displays a warning to users that they should be nervous about using this setting:</p>
<pre class="snippet numbered"><ol class="snippet"><li value="28"><span style="color: #24292E">    </span><span style="color: #D73A49">if</span><span style="color: #24292E"> </span><span style="color: #D73A49">not</span><span style="color: #24292E"> verify:</span></li><li value="29"><span style="color: #24292E">        urllib3.disable_warnings()</span></li><li value="30"><span style="color: #24292E">        </span><span style="color: #005CC5">print</span><span style="color: #24292E">(</span><span style="color: #032F62">'</span><span style="color: #005CC5">\n</span><span style="color: #032F62">*** Warning! TLS verification disabled! ***</span><span style="color: #005CC5">\n</span><span style="color: #032F62">'</span><span style="color: #24292E">)</span></li><li value="31"><span style="color: #24292E">        </span><span style="color: #005CC5">print</span><span style="color: #24292E">(</span><span style="color: #032F62">' This is highly insecure in Real Life™ applications and must'</span><span style="color: #24292E">)</span></li><li value="32"><span style="color: #24292E">        </span><span style="color: #005CC5">print</span><span style="color: #24292E">(</span><span style="color: #032F62">' only be permitted under controlled conditions (such as'</span><span style="color: #24292E">)</span></li><li value="33"><span style="color: #24292E">        </span><span style="color: #005CC5">print</span><span style="color: #24292E">(</span><span style="color: #032F62">' during development).</span><span style="color: #005CC5">\n</span><span style="color: #032F62">'</span><span style="color: #24292E">)</span></li></ol></pre>
<h2 id="connect-to-server">Connect to server</h2>
<p>Next, it attempts to connect to the Reach RPC Server and throws an error if it does not respond quickly enough:</p>
<pre class="snippet numbered"><ol class="snippet"><li value="35"><span style="color: #24292E">    </span><span style="color: #6A737D"># From: https://gist.github.com/butla/2d9a4c0f35ea47b7452156c96a4e7b12</span></li><li value="36"><span style="color: #24292E">    start_time </span><span style="color: #D73A49">=</span><span style="color: #24292E"> time.perf_counter()</span></li><li value="37"><span style="color: #24292E">    </span><span style="color: #D73A49">while</span><span style="color: #24292E"> </span><span style="color: #005CC5">True</span><span style="color: #24292E">:</span></li><li value="38"><span style="color: #24292E">        </span><span style="color: #D73A49">try</span><span style="color: #24292E">:</span></li><li value="39"><span style="color: #24292E">            </span><span style="color: #D73A49">with</span><span style="color: #24292E"> socket.create_connection((host, port), </span><span style="color: #E36209">timeout</span><span style="color: #D73A49">=</span><span style="color: #24292E">timeout):</span></li><li value="40"><span style="color: #24292E">                </span><span style="color: #D73A49">break</span></li><li value="41"><span style="color: #24292E">        </span><span style="color: #D73A49">except</span><span style="color: #24292E"> </span><span style="color: #005CC5">OSError</span><span style="color: #24292E"> </span><span style="color: #D73A49">as</span><span style="color: #24292E"> ex:</span></li><li value="42"><span style="color: #24292E">            time.sleep(</span><span style="color: #005CC5">0.01</span><span style="color: #24292E">)</span></li><li value="43"><span style="color: #24292E">            </span><span style="color: #D73A49">if</span><span style="color: #24292E"> time.perf_counter() </span><span style="color: #D73A49">-</span><span style="color: #24292E"> start_time </span><span style="color: #D73A49">&gt;=</span><span style="color: #24292E"> timeout:</span></li><li value="44"><span style="color: #24292E">                </span><span style="color: #D73A49">raise</span><span style="color: #24292E"> </span><span style="color: #005CC5">TimeoutError</span><span style="color: #24292E">(</span><span style="color: #032F62">'Waited too long for the port </span><span style="color: #005CC5">{}</span><span style="color: #032F62"> '</span></li><li value="45"><span style="color: #24292E">                                   </span><span style="color: #032F62">'on host </span><span style="color: #005CC5">{}</span><span style="color: #032F62"> to accept connection.'</span></li><li value="46"><span style="color: #24292E">                                   .format(port, host)) </span><span style="color: #D73A49">from</span><span style="color: #24292E"> ex</span></li></ol></pre>
<h2 id="define-rpc">Define rpc</h2>
<p>It defines a function, <code>rpc</code>, which will be returned later on, that implements the protocol for synchronous value RPC methods. It formats a given request, posts it, and then returns the deserialized result. It prints debugging information for convenience.</p>
<pre class="snippet numbered"><ol class="snippet"><li value="52"><span style="color: #24292E">    </span><span style="color: #D73A49">def</span><span style="color: #24292E"> </span><span style="color: #6F42C1">rpc</span><span style="color: #24292E">(m, </span><span style="color: #D73A49">*</span><span style="color: #24292E">args):</span></li><li value="53"><span style="color: #24292E">        lab </span><span style="color: #D73A49">=</span><span style="color: #24292E"> </span><span style="color: #032F62">'RPC </span><span style="color: #005CC5">%s</span><span style="color: #032F62"> </span><span style="color: #005CC5">%s</span><span style="color: #032F62">'</span><span style="color: #24292E"> </span><span style="color: #D73A49">%</span><span style="color: #24292E"> (m, json.dumps([</span><span style="color: #D73A49">*</span><span style="color: #24292E">args]))</span></li><li value="54"><span style="color: #24292E">        debug(lab)</span></li><li value="55"><span style="color: #24292E">        ans </span><span style="color: #D73A49">=</span><span style="color: #24292E"> requests.post(</span><span style="color: #032F62">'https://</span><span style="color: #005CC5">%s</span><span style="color: #032F62">:</span><span style="color: #005CC5">%s%s</span><span style="color: #032F62">'</span><span style="color: #24292E"> </span><span style="color: #D73A49">%</span><span style="color: #24292E"> (host, port, m),</span></li><li value="56"><span style="color: #24292E">                            </span><span style="color: #E36209">json</span><span style="color: #24292E">    </span><span style="color: #D73A49">=</span><span style="color: #24292E"> [</span><span style="color: #D73A49">*</span><span style="color: #24292E">args],</span></li><li value="57"><span style="color: #24292E">                            </span><span style="color: #E36209">headers</span><span style="color: #24292E"> </span><span style="color: #D73A49">=</span><span style="color: #24292E"> {</span><span style="color: #032F62">'X-API-Key'</span><span style="color: #24292E">: key},</span></li><li value="58"><span style="color: #24292E">                            </span><span style="color: #E36209">verify</span><span style="color: #24292E">  </span><span style="color: #D73A49">=</span><span style="color: #24292E"> verify)</span></li><li value="59"><span style="color: #24292E">        ans.raise_for_status()</span></li><li value="60"><span style="color: #24292E">        debug(</span><span style="color: #032F62">'</span><span style="color: #005CC5">%s</span><span style="color: #032F62"> ==&gt; </span><span style="color: #005CC5">%s</span><span style="color: #032F62">'</span><span style="color: #24292E"> </span><span style="color: #D73A49">%</span><span style="color: #24292E"> (lab, json.dumps(ans.json())))</span></li><li value="61"><span style="color: #24292E">        </span><span style="color: #D73A49">return</span><span style="color: #24292E"> ans.json()</span></li></ol></pre>
<h2 id="define-rpc_callbacks">Define rpc_callbacks</h2>
<p>It defines a function, rpc_callbacks, which will be returned later on, that implements the protocol for interactive RPC methods. On lines 64 and 65, this function inspects its third argument, cbacks, and separates the callable arguments from the values and creates the intermediate objects, vals and meths, to provide the RPC invocation. After it makes the call, in the while loop starting on line 68, it inspects the result to determine if it is a final answer or an interactive RPC callback. If it is a callback, as indicated by the test on line 72, then it extracts the name of the method, p['m'], and invokes it in the original third argument, cbacks, with the provided arguments. It replaces the p value with the result of that continuation invocation and continues:</p>
<pre class="snippet numbered"><ol class="snippet"><li value="63"><span style="color: #24292E">    </span><span style="color: #D73A49">def</span><span style="color: #24292E"> </span><span style="color: #6F42C1">rpc_callbacks</span><span style="color: #24292E">(m, arg, cbacks):</span></li><li value="64"><span style="color: #24292E">        vals  </span><span style="color: #D73A49">=</span><span style="color: #24292E"> {k: v    </span><span style="color: #D73A49">for</span><span style="color: #24292E"> k, v </span><span style="color: #D73A49">in</span><span style="color: #24292E"> cbacks.items() </span><span style="color: #D73A49">if</span><span style="color: #24292E"> </span><span style="color: #D73A49">not</span><span style="color: #24292E"> </span><span style="color: #005CC5">callable</span><span style="color: #24292E">(v)}</span></li><li value="65"><span style="color: #24292E">        meths </span><span style="color: #D73A49">=</span><span style="color: #24292E"> {k: </span><span style="color: #005CC5">True</span><span style="color: #24292E"> </span><span style="color: #D73A49">for</span><span style="color: #24292E"> k, v </span><span style="color: #D73A49">in</span><span style="color: #24292E"> cbacks.items() </span><span style="color: #D73A49">if</span><span style="color: #24292E">     </span><span style="color: #005CC5">callable</span><span style="color: #24292E">(v)}</span></li><li value="66"><span style="color: #24292E">        p     </span><span style="color: #D73A49">=</span><span style="color: #24292E"> rpc(m, arg, vals, meths)</span></li><li value="67"></li><li value="68"><span style="color: #24292E">        </span><span style="color: #D73A49">while</span><span style="color: #24292E"> </span><span style="color: #005CC5">True</span><span style="color: #24292E">:</span></li><li value="69"><span style="color: #24292E">            </span><span style="color: #D73A49">if</span><span style="color: #24292E"> p[</span><span style="color: #032F62">'t'</span><span style="color: #24292E">] </span><span style="color: #D73A49">==</span><span style="color: #24292E"> </span><span style="color: #032F62">'Done'</span><span style="color: #24292E">:</span></li><li value="70"><span style="color: #24292E">                </span><span style="color: #D73A49">return</span><span style="color: #24292E"> p</span></li><li value="71"></li><li value="72"><span style="color: #24292E">            </span><span style="color: #D73A49">elif</span><span style="color: #24292E"> p[</span><span style="color: #032F62">'t'</span><span style="color: #24292E">] </span><span style="color: #D73A49">==</span><span style="color: #24292E"> </span><span style="color: #032F62">'Kont'</span><span style="color: #24292E">:</span></li><li value="73"><span style="color: #24292E">                cback </span><span style="color: #D73A49">=</span><span style="color: #24292E"> cbacks[p[</span><span style="color: #032F62">'m'</span><span style="color: #24292E">]]</span></li><li value="74"><span style="color: #24292E">                ans   </span><span style="color: #D73A49">=</span><span style="color: #24292E"> cback(</span><span style="color: #D73A49">*</span><span style="color: #24292E">p[</span><span style="color: #032F62">'args'</span><span style="color: #24292E">])</span></li><li value="75"><span style="color: #24292E">                p     </span><span style="color: #D73A49">=</span><span style="color: #24292E"> rpc(</span><span style="color: #032F62">'/kont'</span><span style="color: #24292E">, p[</span><span style="color: #032F62">'kid'</span><span style="color: #24292E">], ans)</span></li><li value="76"></li><li value="77"><span style="color: #24292E">            </span><span style="color: #D73A49">else</span><span style="color: #24292E">:</span></li><li value="78"><span style="color: #24292E">                </span><span style="color: #D73A49">raise</span><span style="color: #24292E"> </span><span style="color: #005CC5">Exception</span><span style="color: #24292E">(</span><span style="color: #032F62">'Illegal callback return: </span><span style="color: #005CC5">%s</span><span style="color: #032F62">'</span><span style="color: #24292E"> </span><span style="color: #D73A49">%</span><span style="color: #24292E"> json.dumps(p))</span></li></ol></pre>
<h2 id="return-references">Return references</h2>
<p>Finally, it returns rpc and rpc_callbacks to the user:</p>
<pre class="snippet numbered"><ol class="snippet"><li value="80"><span style="color: #24292E">    </span><span style="color: #D73A49">return</span><span style="color: #24292E"> rpc, rpc_callbacks</span></li></ol></pre>